<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | Things I Learned about Rails Today]]></title>
  <link href="http://steven-ferguson.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://steven-ferguson.github.io/"/>
  <updated>2014-07-19T15:08:37-07:00</updated>
  <id>http://steven-ferguson.github.io/</id>
  <author>
    <name><![CDATA[Steven]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Duck Typing]]></title>
    <link href="http://steven-ferguson.github.io/blog/2014/06/16/duck-typing/"/>
    <updated>2014-06-16T23:28:18-07:00</updated>
    <id>http://steven-ferguson.github.io/blog/2014/06/16/duck-typing</id>
    <content type="html"><![CDATA[<p>One of my big breakthroughs in understanding object oriented design in Ruby came when I learned about <a href="http://en.wikipedia.org/wiki/Duck_typing">duck typing</a>. Wikipedia provides a nice definiition of the concept:</p>

<blockquote><p>duck typing is a style of typing in which an object&rsquo;s methods and properties determine the valid semantics, rather than its inheritance from a particular class or implementation of an explicit interface.</p></blockquote>

<p>This means that in Ruby it does not matter if an object is a specific type or class, only that it can respond to a given message. For example, in the <code>stringify</code> method below, it does not matter if the argument is an integer or symbol or some other class, only that it can respond to the <code>to_s</code> method.</p>

<pre><code>def stringify(a)
  a.to_s
end

stringify(1)
=&gt; "1"

stringify(:hello)
=&gt; "hello"

class NewClass
  def to_s
    "works for custom objects too!"
  end
end

stringify(NewClass.new)
=&gt; "works for custom objects too!"
</code></pre>

<p>Not having to care about a specific object&rsquo;s class enables a lot of flexiblity for swaping out collaborator objects. To illustrate this, let&rsquo;s take a look at an example:</p>

<h3>File Storage with Duck Typing</h3>

<p>My app generates reports, and I would like to save these reports. Initially, I just want to save the reports to my local disk.</p>

<p>```ruby
class Report
  def initialize(name, data)</p>

<pre><code>@name = name
@data = data
</code></pre>

<p>  end</p>

<p>  def save_to(storage)</p>

<pre><code>storage.store(@name, @data)
</code></pre>

<p>  end
end</p>

<p>class FileStorage
  def store(file_name, data)</p>

<pre><code>File.open("reports/#{file_name}", 'w') do |file|
  file.write(data)
end
</code></pre>

<p>  end
end</p>

<p>report = Report.new(&lsquo;Sales Figures&rsquo;, &lsquo;sales data blah&hellip;&rsquo;)
file_store = FileStorage.new
report.save_to(file_store)
```</p>

<p>Later, I decide that it would also be nice to have the ability to upload reports to S3. With duck typing, implementing this new feature is as simple as creating a new class for uploading to S3 which implements a <code>store</code> method:</p>

<p>```ruby
class S3Storage
  def initialize(bucket_name)</p>

<pre><code>@bucket = AWS::S3.new.buckets[bucket_name]
</code></pre>

<p>  end</p>

<p>  def store(file_name, data)</p>

<pre><code>@bucket.objects.create(file_name, data)
</code></pre>

<p>  end
end</p>

<p>report = Report.new(&lsquo;Sales Figures&rsquo;, &lsquo;sales data blah&hellip;&rsquo;)
s3_store = S3Storage.new(&lsquo;my_bucket&rsquo;)
report.save_to(s3_store)
```</p>

<p>Start thinking about objects in terms of the messages they receive, and you will be rewarded with the flexibility that duck typing allows.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using RSpec Shared Context for DRYer Specs]]></title>
    <link href="http://steven-ferguson.github.io/blog/2014/05/17/using-rspec-shared-context-for-dryer-specs/"/>
    <updated>2014-05-17T18:20:42-07:00</updated>
    <id>http://steven-ferguson.github.io/blog/2014/05/17/using-rspec-shared-context-for-dryer-specs</id>
    <content type="html"><![CDATA[<p>Do you ever find that many of your specs have a similar setup that you are repeating over and over? I often find this happening when I&rsquo;m writing feature specs that require a logged in user. For example:</p>

<p>```ruby  <br/>
feature &lsquo;some super cool feature&rsquo; do
  background &lsquo;login an admin&rsquo; do</p>

<pre><code>user = create(:user, role: 'admin')
user.confirm!
login_as(user, scope: :user)
</code></pre>

<p>  end</p>

<p>  scenario &lsquo;my super cool scenario&rsquo; do
  &hellip;
  end
end
```</p>

<p>If my login or authentication process changes, I have to manually go into each spec and change the code. I also find that this setup code clutters the spec and makes it harder to read. If we could extract the setup code and replace it with an easy to read single line, it would solve both of these problems.</p>

<p><a href="https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-context">RSpec shared contexts</a> provide just this type of solution. Using a shared context we can extract the setup into its own file, and rewrite our feature spec in a cleaner way:</p>

<p>```ruby
feature &lsquo;some super cool feature&rsquo; do
  include_context &lsquo;a logged in admin&rsquo;</p>

<p>  scenario &lsquo;my super cool scenario&rsquo; do
  &hellip;
  end
end
```</p>

<p>To create a shared context:
```ruby</p>

<h1>./spec/support/shared_contexts/a_logged_in_admin.rb</h1>

<p>shared_context &lsquo;a logged in admin&rsquo; do
  before &lsquo;create and login admin&rsquo; do</p>

<pre><code>user = create(:user, role: 'admin')
user.confirm!
login_as(user, scope: :user)
</code></pre>

<p>  end
end
```</p>

<p>Since all files located in <code>spec/support</code> are automatically required in the default <code>spec_helper.rb</code>, we can call the context from any spec. Now when we need to change how a user is logged in, we just have to change the code in our shared context and without having to change our specs.</p>
]]></content>
  </entry>
  
</feed>
